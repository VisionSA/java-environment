/**
 * @id 4899
 * Class LiquidarSaldo0Bean.
 * User José Casalis
 * Bizit Global - Año 2012
 */
package com.bizitglobal.webapp.faces.beans.transacciones;

import java.io.File;
import java.io.IOException;
import java.math.BigDecimal;
import java.sql.Timestamp;
import java.text.Format;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.servlet.http.HttpServletRequest;

import net.sf.jasperreports.engine.JRException;

import org.apache.log4j.Logger;

import com.bizitglobal.tarjetafiel.commons.filtros.Filtro;
import com.bizitglobal.tarjetafiel.commons.util.PropertieFile;
import com.bizitglobal.tarjetafiel.evaluacion.exception.IndividuoEvaluacionException;
import com.bizitglobal.tarjetafiel.evaluacion.negocio.IndividuoEvaluacion;
import com.bizitglobal.tarjetafiel.general.exception.NoLaborableException;
import com.bizitglobal.tarjetafiel.general.negocio.Domicilio;
import com.bizitglobal.tarjetafiel.operador.negocio.Operador;
import com.bizitglobal.tarjetafiel.transacciones.exception.ClienteTransaccionException;
import com.bizitglobal.tarjetafiel.transacciones.exception.GestorLiquidacionClienteException;
import com.bizitglobal.tarjetafiel.transacciones.negocio.ClienteLiquidacion;
import com.bizitglobal.tarjetafiel.transacciones.negocio.ClienteTransaccion;
import com.bizitglobal.tarjetafiel.transacciones.negocio.Concepto;
import com.bizitglobal.tarjetafiel.transacciones.negocio.CtaCteCliente;
import com.bizitglobal.tarjetafiel.transacciones.negocio.GestorLiquidacionCliente;
import com.bizitglobal.tarjetafiel.transacciones.negocio.ItemLiquidacion;
import com.bizitglobal.tarjetafiel.transacciones.negocio.LiqCliente;
import com.bizitglobal.tarjetafiel.transacciones.negocio.LiqClienteRepactacion;
import com.bizitglobal.tarjetafiel.transacciones.negocio.LiquidacionClientes;
import com.bizitglobal.tarjetafiel.transacciones.negocio.ListaPrecioDetalle;
import com.bizitglobal.tarjetafiel.transacciones.negocio.ListaPrecioItem;
import com.bizitglobal.tarjetafiel.transacciones.service.impl.CalculoCuotaServicesImpl;
import com.bizitglobal.webapp.faces.beans.BaseBean;
import com.bizitglobal.webapp.faces.util.GeneradorDeInforme;
import com.bizitglobal.webapp.faces.util.Session;


/**
 * @id 4899
 * @author José Casalis. Bizit Global - Año 2012
 */
@SuppressWarnings({"rawtypes","unchecked"})
public class LiquidarSaldo0Bean extends BaseBean {

	private static final Logger log = Logger.getLogger(LiquidarSaldo0Bean.class);
	private String LIQUIDAR_SALDO_0 = "liquidarSaldo0";

	private Long cuentaLiquidar;
	private List<ItemLiquidacion> listaItemsLiquidaciones;
	private Boolean permitirLiquidar;
	private ClienteTransaccion cliente = null;
	private Boolean verDetalles = false;

	private Date fechaPrimerVencimiento;
	private Date fechaSegundoVencimiento;
	private Date fechaTercerVencimiento;
	private Date fechaCierreAnterior;
	private Date fechaCierreActual;
	private Date fechaCierreProximo;
	private Date fechaVencimientoAnterior;
	private Date fechaVencimientoProximo;
	private BigDecimal montoAdeudado = new BigDecimal(0);
	private Map mapaTransacciones = null; // aqui almaceno como key el id de transaccion, y como ArrayList las cuotas de estas transacciones.
	public BigDecimal saldoTotal = new BigDecimal(0);
	public BigDecimal lineaDeCredito = new BigDecimal(0);
	public BigDecimal disponible = new BigDecimal(0);
	String popupReport = "";

	LiquidacionClientes liquidacionEditada = null; // este objeto es para las liquidaciones particulares.

	private String directorioRelativoLiquidacion;
	SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");

	private GestorLiquidacionCliente gestor = null;

	private String mensajeExito = "";


	/**
	 * Constructor for class LiquidarSaldo0Bean
	 */
	public LiquidarSaldo0Bean() {
		super();
		borrar();
	}


	@Override
	public void borrar() {
		tituloCorto = "Liquidación de Cuentas con Saldo 0";
		tituloLargo = "TARJETA FIEL";
		permitirLiquidar = false;
		cuentaLiquidar = 0L;
		listaItemsLiquidaciones = null;
		cliente = null;
		verDetalles = false;
	}


	@Override
	public boolean validar() {
		// TODO Auto-generated method stub
		return false;
	}


	@Override
	public String inicializar() {
		borrarBaseBean();
		borrar();
		return LIQUIDAR_SALDO_0;
	}


	public String cancelar() {
		// borrar();
		ejecutarJavaScript("window.close();");
		return LIQUIDAR_SALDO_0;
	}


	public String irAContinuar() {
		limpiarMensajeExito();
		borrar();
		return LIQUIDAR_SALDO_0;
	}


	private void limpiarMensajeExito() {
		popup.borrar();
	}


	public String irASalir() {
		return cancelar();
	}


	/**
	 * @id: Method: buscarCuenta Description: Busca cuentas que tengan saldo 0, items todos conciliados y que tengan items para liquidar
	 * @return
	 */
	public String buscarCuenta() {
		try {
			error.borrar();
			if (cuentaLiquidar == null || cuentaLiquidar.equals(0L)) {
				error.agregar("Ingrese una cuenta valida");
				borrar();
				return LIQUIDAR_SALDO_0;
			}

			cliente = transaccionesService.getClienteTransaccionService().leerCliente(cuentaLiquidar);
			Boolean hayItemsNoConciliados = transaccionesService.getCtaCteClienteService().hayItemsNoConciliados(cuentaLiquidar);
			if (hayItemsNoConciliados) {
				error.agregar("La cuenta posee items no conciliados");
				borrar();
				return LIQUIDAR_SALDO_0;
			}

			listaItemsLiquidaciones = transaccionesService.getItemLiquidacionService().getItemsDeLiquidacionEspecial(
					Integer.parseInt(cuentaLiquidar.toString()));
			log.info("Cantidad de items: " + listaItemsLiquidaciones.size());
			if (listaItemsLiquidaciones.isEmpty()) {
				error.agregar("La cuenta no posee items para liquidar");
				borrar();
				return LIQUIDAR_SALDO_0;
			}

			Double saldoCuenta = 0D;
			/* @I4899 */
			/* en este metodo se pasa el valor null para que tome el saldo total de la cuenta sin tener en cuenta la fecha */
			saldoCuenta = transaccionesService.getCtaCteClienteService().getSaldoAnteriorComposicionSaldo(null, cuentaLiquidar);
			/* @F4899 */
			if (!saldoCuenta.equals(0D)) {
				error.agregar("No se permite realizar esta liquidacion porque el saldo de la cuenta no es 0 (cero)");
				borrar();
				return LIQUIDAR_SALDO_0;
			}
			permitirLiquidar = true;
			verDetalles = true;

		} catch (NumberFormatException e) {
			e.getStackTrace();
			log.error("Error en el número de cuenta, posee caracteres inválidos");
			error.agregar("Error en el número de cuenta, posee caracteres inválidos");
			borrar();
			return LIQUIDAR_SALDO_0;
		} catch (Exception e) {
			e.getStackTrace();
			log.error("Error al intentar obtener los items a liquidar");
			error.agregar("Error en la lectura de los items de la cuenta corriente");
			borrar();
			return LIQUIDAR_SALDO_0;
		}

		return LIQUIDAR_SALDO_0;
	}


	/**
	 * @id: Method: liquidar Description: Liquida los items que tiene pendiente la cuenta. Esta liquidacon no genera cargos ni calcula intereses
	 * @return
	 */
	public String liquidar() {

		try {
			liquidarPorAdelantado();
		} catch (NoLaborableException e) {
			e.printStackTrace();
			log.error(e.getMessage());
			error.agregar("Error al intentar obtener los días no laborales");
			borrar();
			return LIQUIDAR_SALDO_0;
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getMessage());
			error.agregar("Error al intentar generar la liquidacion");
			borrar();
			return LIQUIDAR_SALDO_0;
		}

		popup.setMensaje(mensajeExito);
		popup.setMostrar(true);

		cliente = null;
		listaItemsLiquidaciones = null;
		cuentaLiquidar = 0L;
		permitirLiquidar = false;
		verDetalles = false;
		return LIQUIDAR_SALDO_0;
	}


	public void liquidarPorAdelantado() throws Exception {
		// Arma un mapa para saber que items liquidar
		mapaTransacciones = new HashMap();
		Iterator listaIt = listaItemsLiquidaciones.iterator();
		/* @I4899 */Filtro filtroPagos = new Filtro();

		while (listaIt.hasNext()) {
			ItemLiquidacion itmAct = (ItemLiquidacion) listaIt.next();
			// if (itmAct.getCodigoConcepto() == 2){//SU PAGO
			filtroPagos = new Filtro();
			/* @I4899 */
			if (itmAct.getComprobante() != 0) {
				filtroPagos.agregarCampoOperValor("idTranascciones", Filtro.IGUAL, itmAct.getComprobante());
				filtroPagos.agregarCampoOperValor("nroCuota", Filtro.IGUAL, itmAct.getCuota());
			} else {
				filtroPagos.agregarCampoOperValor("idCtacteCliente", Filtro.IGUAL, itmAct.getIdCtaCte());
			}
			/* @F4899 */
			List<CtaCteCliente> ctacte = transaccionesService.getCtaCteClienteService().getCtaCteCliente(filtroPagos);
			Calendar nuevaFechaCierre = Calendar.getInstance();
			Iterator<CtaCteCliente> ctacteIt = ctacte.iterator();
			while (ctacteIt.hasNext()) {
				CtaCteCliente ctaTemp = ctacteIt.next();
				ctaTemp.setFechaFacturacion(new Timestamp(nuevaFechaCierre.getTimeInMillis()));
				transaccionesService.getCtaCteClienteService().actualizarCtaCteCliente(ctaTemp);
				// }
				log.info(ctacte.size());

			}
		}

		/* @F4899 */listaIt = listaItemsLiquidaciones.iterator();
		while (listaIt.hasNext()) {
			ItemLiquidacion itm = (ItemLiquidacion) listaIt.next();
			if (mapaTransacciones.containsKey(Long.valueOf(itm.getComprobante()))) {
				List mapa = (ArrayList) mapaTransacciones.get(Long.valueOf(itm.getComprobante()));
				mapa.add(Long.valueOf(itm.getCuota()));
			} else {
				List mapa = new ArrayList();
				mapa.add(Long.valueOf(itm.getCuota()));
				mapaTransacciones.put(Long.valueOf(itm.getComprobante()), mapa);
			}
		}

		Concepto conceptoPagos = null;
		Concepto conceptoRepactaciones = null;
		Concepto conceptoParamGen = null;
		Set detallesSellos = null; // los concepto detalles del sello
		ListaPrecioItem[] repactaciones = null;
		ListaPrecioDetalle[] pagos = null;
		Operador oper;
		oper = Session.getOperador();
		String rutaRelativa;
		// recupero el dia que de cierre, en el cual estoy queriendo liquidar

		Calendar calendar = Calendar.getInstance();
		int diaCierre = calendar.get(Calendar.DATE);

		gestor = new GestorLiquidacionCliente();
		Calendar cal = Calendar.getInstance();
		cal.add(Calendar.MONTH, -2);

		// recupero los dias no laborables que creo apropiados y se los paso a el gestor de liquidacion.
		Filtro filtro = new Filtro("fecha", Filtro.MAYOR, Filtro.getTO_DATE(new Timestamp(cal.getTimeInMillis())));
		cal.add(Calendar.MONTH, 6);
		filtro.agregarCampoOperValor("fecha", Filtro.MENOR_IGUAL, Filtro.getTO_DATE(new Timestamp(cal.getTimeInMillis())));
		List listaDiasNoLaborables = null;

		listaDiasNoLaborables = generalService.getNoLaborableService().getNoLaborable(filtro);
		gestor.setDiasFeriados(listaDiasNoLaborables);

		try {
			// recupero el concepto de LIQUIDACION REPACTACIONES (id nro. 11), para obtener la lista de precios que utiliza
			conceptoRepactaciones = transaccionesService.getConceptoService().leerConcepto(new Long(11));
			conceptoRepactaciones.armarConcepto();
			conceptoRepactaciones.armarReglaConcepto();
		} catch (Exception e) {
			log.error(e, e);
			throw new GestorLiquidacionClienteException(
					"Error al intentar utilizar el Concepto 11 (Repactaciones). Este debe tener asociado la lista de precio y debe encuentre en vigencia.");
		}

		/**
		 * Calculo de fecha a utilizar en la liquidacion
		 */
		Date fechaActual = Calendar.getInstance().getTime();
		fechaPrimerVencimiento = addDiasFechaLaborable(fechaActual, 0);
		fechaSegundoVencimiento = fechaPrimerVencimiento;
		fechaTercerVencimiento = fechaPrimerVencimiento;

		/* @I4899 */// Leemos la ultima liquidacion para poder calcular el saldo a la fecha de la misma, ya que el saldo a la fecha actual seria
					// incorrecto
		LiqCliente lq = transaccionesService.getLiqClienteService().getUltimaLiquidacion(cliente.getId());
		// El concepto 187 se lee para saber si es posterior a la última liquidacion y poder tomar o no su fecha como vencimientoAnterior
		Filtro saldoInicialFiltro = new Filtro();
		saldoInicialFiltro.agregarCampoOperValor("conceptoDetalle.idConceptoDetalle", Filtro.IGUAL, "187");
		saldoInicialFiltro.agregarCampoOperValor("clienteTransaccion.idCliente", Filtro.IGUAL, cliente.getIdCliente());
		List<CtaCteCliente> saldoInicial = transaccionesService.getCtaCteClienteService().getCtaCteCliente(saldoInicialFiltro);
		// Se obtiene el primero, ya que puede tener como máximo un item de este tipo
		CtaCteCliente sInicial = null;
		if (!saldoInicial.isEmpty()) {

			sInicial = saldoInicial.get(0);
		}
		// En caso de que no tenga liquidaciones ni saldo anterior, le ponemos como fecha para calcular el saldo la fecha de creacion de la cuenta
		/* @I4899 */
		if (lq == null && sInicial == null) {
			fechaCierreAnterior = cliente.getFechaAlta();
		} else {
			if (lq != null && sInicial != null) {
				// Si el saldo inicial es posterior a la última liq, toma fecha saldo inicial
				if (sInicial.getFechaFacturacion() != null && sInicial.getFechaFacturacion().after(lq.getFechaCierre())) {
					fechaCierreAnterior = sInicial.getFechaFacturacion();
				} else {
					fechaCierreAnterior = lq.getFechaCierre();
				}
			} else {
				if (sInicial != null) {
					fechaCierreAnterior = sInicial.getFechaFacturacion();
				} else {
					fechaCierreAnterior = lq.getFechaCierre();
				}
			}
		}
		/* @F4899 */
		fechaCierreActual = fechaActual;
		/* @F4899 */fechaCierreProximo = fechaActual;

		fechaVencimientoAnterior = addDiasFechaLaborable(fechaActual, 15);
		fechaVencimientoProximo = fechaVencimientoAnterior;

		// recupero la fecha de cierre.
		IndividuoEvaluacion indi;
		Integer diaDePago = null;
		try {
			indi = (IndividuoEvaluacion) evaluacionService.getIndividuoEvaluacionService().leerIndividuo(cliente.getIndividuo().getIdIndividuo());
			diaDePago = indi.getDiaPago().getDiaPago();
		} catch (IndividuoEvaluacionException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		Calendar cie = Calendar.getInstance();
		int dia = cie.get(Calendar.DATE);
		if (diaDePago.intValue() <= dia) {
			cie.set(Calendar.DATE, diaDePago.intValue());
		} else {
			cie.set(Calendar.DATE, diaDePago.intValue());
			cie.add(Calendar.MONTH, -1);
		}

		// Creo un objeto liquidacion Clientes.
		liquidacionEditada = new LiquidacionClientes(null, Calendar.getInstance().getTime(), "N", "N", new HashSet(), listaDiasNoLaborables,
				new Timestamp(Calendar.getInstance().getTime().getTime()), 3, cie.getTime());

		diaCierre = cie.get(Calendar.DATE);
		Long idCliente = cliente.getIdCliente();
		// una variable para el monto suma de todas las liquidaciones clientes.
		BigDecimal montoTotalLiquidacionClientes = new BigDecimal(0);
		// // Se graba directamente, ya que al ser una preliquidacion no existia el objeto aun.
		Calendar cale = Calendar.getInstance();
		Timestamp times = new Timestamp(cale.getTimeInMillis());
		liquidacionEditada.setFechaPreliq(times);
		transaccionesService.getLiquidacionClientesService().grabarLiquidacionClientes(liquidacionEditada);

		try {
			// recupero el concepto de LIQUIDACION PAGOS (id nro. 10), para obtener la lista de precios que utiliza
			conceptoPagos = transaccionesService.getConceptoService().leerConcepto(new Long(10));
			conceptoPagos.armarConcepto();
			conceptoPagos.armarReglaConcepto();
		} catch (Exception e) {
			log.error(e, e);
			throw new GestorLiquidacionClienteException(
					"Error al intentar utilizar el Concepto 10 (Pagos). Este debe tener asociado la lista de precio y debe encuentre en vigencia.");
		}

		String nombreLiq = "";
		// Creo el directorio de la presente liquidacion particular, este directorio se obtien de contexto properties.
		SimpleDateFormat formatoFecha = new SimpleDateFormat("dd-MM-yyyy");
		String key;
		key = "catalina.home";
		key = System.getProperty(key);
		log.info(key + "/webapps/contexto.properties");
		PropertieFile prop = new PropertieFile(key + "/webapps/contexto.properties");
		try {
			String key1;
			key1 = "catalina.home";
			key1 = System.getProperty(key);

			nombreLiq = System.getProperty("catalina.home") + "/" + prop.getProperties("directorioArchivos") +
					prop.getProperties("directorioLiquidacionesClientes") + "/Especiales";

			File directorio = new File(nombreLiq);
			if (!directorio.exists()) {
				try {
					if (!directorio.mkdir()) {

						throw new Exception("No se ha podido crear el directorio para almacenar las liquidaciones.");
					}
				} catch (Exception e) {
					e.printStackTrace();
					throw new Exception("No se ha podido crear el directorio para almacenar las liquidaciones.");
				}

			}
		} catch (Exception e) {
			e.printStackTrace();
			throw new GestorLiquidacionClienteException("No se ha podido crear el directorio para almacenar las liquidaciones.");
		}

		// Tenemos un solo cliente para liquidar por adelantado, entonces no hace falta iterar el proceso de liquidacion.
		idCliente = cliente.getIdCliente();
		log.info("Liquidare cliente:" + idCliente);

		try {
			// Pagos: aqui tengo que enviarle el id del cliente....
			Set detallesPagos = conceptoPagos.getListaPrecio(idCliente).getVersionVigente().getDetallesListaPrecio();
			pagos = new ListaPrecioDetalle[detallesPagos.size()];
			int j = 0;
			Iterator listaPagos = detallesPagos.iterator();
			while (listaPagos.hasNext()) {
				ListaPrecioDetalle var = (ListaPrecioDetalle) listaPagos.next();
				pagos[j] = var;
				j++;
			}
			// ordeno los pagos de menor a mayor en nro de dias.
			for (int i = 0; i < pagos.length - 1; i++) {
				for (int h = i + 1; h < pagos.length; h++) {
					if (pagos[i].getMonto().intValue() > pagos[h].getMonto().intValue()) {
						ListaPrecioDetalle lispredet = pagos[i];
						pagos[i] = pagos[h];
						pagos[h] = lispredet;
					}
				}
			}
		} catch (Exception e) {
			log.error(e, e);
			throw new GestorLiquidacionClienteException(
					"Se produjo un error al intentar formar el set de pagos del cliente. Posibles causas: el Concepto 10 (Pagos) se encuentra fuera de vigencia o no tiene lista precio asociada");
		}

		// calculo el total del cliente...
		BigDecimal[] totalesDeCliente = transaccionesService.getGestorLiquidacionClienteService().totalConsumoParticularCliente(idCliente.intValue(),
				mapaTransacciones);
		BigDecimal totalCliente = totalesDeCliente[0].setScale(2, BigDecimal.ROUND_HALF_DOWN);
		BigDecimal totalInteresesCliente = totalesDeCliente[1];
		BigDecimal totalRepactacionesCliente = totalesDeCliente[2];
		totalCliente = totalCliente.setScale(2, BigDecimal.ROUND_HALF_DOWN);
		totalInteresesCliente = totalInteresesCliente.setScale(2, BigDecimal.ROUND_HALF_DOWN);
		totalRepactacionesCliente = totalRepactacionesCliente.setScale(2, BigDecimal.ROUND_HALF_DOWN);

		// Se calcula la mora anterior antes de impactar la liquidacion, si no hay que utilizar una consulta muy compleja.
		/* @I4899 */
		/* le paso como id de liquidacion un null para que tome los item que hasta ahora no fueron liquidados */
		montoAdeudado = transaccionesService.getGestorLiquidacionClienteService().calcularMoraAnterior(idCliente.intValue(),
				liquidacionEditada.getFechaCierrePeriodo(), null);
		/* @F4899 */
		ClienteLiquidacion cliente = transaccionesService.getClienteLiquidacionService().leerCliente(idCliente);
		cliente.getIndividuo();
		cliente.getNombreCliente();
		lineaDeCredito = cliente.getLimiteCredito();
		saldoTotal = cliente.getSaldoLinea();
		disponible = lineaDeCredito.add(saldoTotal.negate());

		double importe = 0;
		// recupero el porcentaje a cobrar por mora

		// construyo el objeto LiqCliente y se lo agrego al set de nuestro objeto
		LiqCliente liqCliente = new LiqCliente(new BigDecimal(0), new BigDecimal(0), new BigDecimal(0), new BigDecimal(0), new BigDecimal(0),
				new BigDecimal(0), liquidacionEditada);
		liqCliente.setMontoTotal(totalCliente);
		liqCliente.setTotalIntereses(totalInteresesCliente);
		liqCliente.setTotalRepactado(totalRepactacionesCliente);
		liqCliente.setImportePagado(new BigDecimal(0));
		// recupero el intCompensatorio y el punitorio...
		liqCliente.setIntComp(new BigDecimal(0));
		liqCliente.setIntPunitorios(new BigDecimal(0));
		liqCliente.setLineaDeCredito(lineaDeCredito.doubleValue());
		liqCliente.setSaldoTotal(saldoTotal.doubleValue());
		liqCliente.setDisponible(disponible.doubleValue());
		liqCliente.setFechaCierreAnterior(fechaCierreAnterior);
		liqCliente.setFechaLiq(fechaPrimerVencimiento);
		liqCliente.setFechaProxCierre(fechaCierreProximo);
		liqCliente.setFechaVtoAnterior(fechaVencimientoAnterior);
		liqCliente.setFechaProximoVto(fechaVencimientoProximo);
		liqCliente.setFechaCierre(fechaCierreActual);
		liqCliente.setFechaVto3(fechaTercerVencimiento);

		liqCliente.setClienteTransaccion(new ClienteTransaccion(idCliente));
		liquidacionEditada.getLiqClientes().add(liqCliente);

		// VER BIEN ESTO!!... NO VA A FUNCIONAR PARA MUCHOS CLIENTES...
		transaccionesService.getLiqClienteService().grabarLiqCliente(liqCliente);
		transaccionesService.getLiquidacionClientesService().actualizarLiquidacionClientes(liquidacionEditada);

		// Aqui debemos descontar los intereses y el iva, de cuotas que esten a futuro.
		transaccionesService.getGestorLiquidacionClienteService().descontarInteresesEIvaFuturo(idCliente.intValue(), liqCliente, mapaTransacciones);

		// Una vez que ya impacte la ctacte Auxiliar, recupero el monto total que suma en esta tabla la liquidacion, para agregarlo al total del
		// cliente y al monto adeudado.
		BigDecimal importeAux = transaccionesService.getGestorLiquidacionClienteService().getImportesAgregadosPorLiquidacion(
				liqCliente.getIdLiqCliente());
		// Aqui modificar el saldo en linea de el cliente

		totalCliente = totalCliente.add(importeAux);
		// //// Calcule el total agregado hasta ahora como artimaña para considerar bien los sellos.

		// Actualizo la ctaCte cliente seteandole el id de la LiqCliente. Recordar que si el proceso completo no se puede terminar, estos id seran
		// borrados. o sea son provisorios.
		transaccionesService.getGestorLiquidacionClienteService().asignarLiqParticularACtaCteCliente(idCliente.intValue(), liqCliente,
				mapaTransacciones);

		// Se lio resto, porque voy a volver a recalcular.
		totalCliente = totalCliente.add(importeAux.negate());
		// Una vez que ya impacte la ctacte Auxiliar, recupero el monto total que suma en esta tabla la liquidacion, para agregarlo al total del
		// cliente y al monto adeudado.
		importeAux = transaccionesService.getGestorLiquidacionClienteService().getImportesAgregadosPorLiquidacion(liqCliente.getIdLiqCliente());
		// Aqui modificar el saldo en linea de el cliente

		totalCliente = totalCliente.add(importeAux);

		// NO Hace falta asignar la liquidacion en la tabla auxiliar, ya que se le ha pasado por parametro el id de LIqCliente.
		// transaccionesService.getGestorLiquidacionClienteService().asignarLiquidacionACtaCteClienteAux(idCliente.intValue(),
		// liquidacionClientesEditada.getFechaCierrePeriodo(), liqCliente);

		// aqui debo actualizar sies que pago de mas , se lo descuento y ya le pongo como paga la liquidacion

		liqCliente.setResumenAterior(montoAdeudado.setScale(2, BigDecimal.ROUND_HALF_DOWN).doubleValue() +
				totalCliente.setScale(2, BigDecimal.ROUND_HALF_DOWN).doubleValue());

		liqCliente.setMontoTotal(totalCliente);

		// creo el set de repactaciones y el set de pagos.
		// if (!liqCliente.crearSetDePagos(pagos,gestor,interesPorMora.doubleValue()/100)) throw new
		// Exception("No se pudo organizar los pagos del cliente de id: " + idCliente);
		if (!liqCliente.crearSetDePagos(pagos, gestor, 0))
			throw new Exception("No se pudo organizar los pagos del cliente de id: " + idCliente);

		if (!liqCliente.crearSetDeRepactacion(conceptoRepactaciones, (CalculoCuotaServicesImpl)
				/* @I5788 */transaccionesService.lookupService("calculoCuotaServicesTarget"), diaCierre, liqCliente.getFechaCierre()))
			throw new Exception("No se pudo calcular la repactacion del cliente de id: " + idCliente);
		/* @F5788 */// construyo el array de fechas y pagos para pasar al constructor de liqVencimientos futuros...
		Date[] fechas = new Date[6];
		BigDecimal[] montos = new BigDecimal[7];
		// recupero los 6 meses siguientes.... mejorar la consulta.
		BigDecimal totalMes;
		for (int l = 0; l < 6; l++) {
			Calendar calenMes = Calendar.getInstance();
			calenMes.setTime(liquidacionEditada.getFechaCierrePeriodo());
			calenMes.add(Calendar.MONTH, l + 1);
			Date fechaMesQueViene = calenMes.getTime();
			totalMes = transaccionesService.getGestorLiquidacionClienteService().calcularTotalConsumoPorClienteFut(idCliente.intValue(),
					fechaMesQueViene);
			fechas[l] = fechaMesQueViene;
			montos[l] = totalMes;
		}

		// generamos el pdf para esta liqCliente....
		liqCliente.setRutaPdf(generarPDF(liqCliente, idCliente, nombreLiq));

		// BigDecimal pagosAdelantados = transaccionesService.getGestorLiquidacionClienteService().actualizarTablaPagosClientes(
		// liqCliente.getIdLiqCliente(), liqCliente.getMontoTotal(), idCliente,fechaCierreActual);
		Double pagosAdelantados = 0D;

		if (liqCliente.getResumenAterior().doubleValue() < 0) {
			pagosAdelantados = liqCliente.getMontoTotal().doubleValue();
		} else {
			pagosAdelantados = liqCliente.getMontoTotal().doubleValue() - liqCliente.getResumenAterior().doubleValue();

			if (pagosAdelantados < 0) {
				pagosAdelantados = 0D;
			}
		}

		// aqui debo impactar la ctacte cliente si estan cancelados o no.
		if (pagosAdelantados.doubleValue() > 0) {
			/* @I4899 */
			transaccionesService.getCtaCteClienteService().imputarLasCtaCteClientes(pagosAdelantados.doubleValue(), liqCliente);
			/* @F4899 */
			// BigDecimal importePagadoLiquidacion =
			// transaccionesService.getGestorLiquidacionClienteService().calcularImportePagadoLiquidacion(liqCliente.getIdLiqCliente());
			liqCliente.setImportePagado(new BigDecimal(pagosAdelantados).setScale(2, BigDecimal.ROUND_HALF_DOWN));
		}

		transaccionesService.getLiqClienteService().actualizarLiqCliente(liqCliente);
		// por ultimo le acutualizo el saldo en linea al cliente.
		transaccionesService.getGestorLiquidacionClienteService().actualizarSaldoEnLinea(idCliente, importeAux);

		// actualizamos la lista de preliquidaciones particulares hechas para este cliente.
		liquidacionEditada.setFinalizo("S");
		transaccionesService.getLiquidacionClientesService().actualizarLiquidacionClientes(liquidacionEditada);

		/*
		 * Controla si no quedaron items sin liquidar, esto lo hacemos por las dudas que en el mismo momento en que se estaba efectuando la
		 * liquidación por alguna causa se haya agregado algún item en la cuenta corriente
		 */
		listaItemsLiquidaciones = transaccionesService.getItemLiquidacionService().getItemsDeLiquidacion(Integer.parseInt(cuentaLiquidar.toString()));
		// Confirma la liquidación
		liquidacionEditada.setConfirmada("S");
		transaccionesService.getLiquidacionClientesService().actualizarLiquidacionClientes(liquidacionEditada);
		/* @I4981 */
		transaccionesService.getCtaCteClienteService().reimputarCuentaSinCalculoMora(idCliente);
		log.info("Se reimputo la cuenta: " + idCliente);
		/* @F4981 */
		mensajeExito = "La cuenta de " + cliente.getNombreCliente() + " se liquidó correctamente.";

		if (!listaItemsLiquidaciones.isEmpty()) {
			mensajeExito = "\nSe encontraron items en la cuenta sin liquidar, por favor, vuelva a revisar esta cuenta.";
		}
		
		//170628
		transaccionesService.getCtaCteClienteService().corregirImportesImputacion(idCliente);

	}


	@SuppressWarnings({ "unchecked", "rawtypes" })
	public String generarPDF(LiqCliente liquidacionCliente, Long idCliente, String rutaRelativa) throws GestorLiquidacionClienteException {
		popupReport = new String("");
		HttpServletRequest request = Session.getRequest();
		SimpleDateFormat formatoFecha = new SimpleDateFormat("dd-MM-yyyy");
		ClienteTransaccion clienteT;
		String nombreLiq = "";
		String nombreLiqReturn = "";
		try {
			clienteT = transaccionesService.getClienteTransaccionService().leerCliente(liquidacionCliente.getClienteTransaccion().getIdCliente());

			String codPost = null;

			// Composicion de la informacion del cliente
			String nombre = "NOMBRE INCORRECTO";
			String domicilio = "DOMICILIO INCORRECTO";
			String localidad = "LOCALIDAD INCORRECTA";
			String cp = "CP INCORRECTO";
			String provincia = "PROVINCIA INCORRECTA";
			try {
				IndividuoEvaluacion individuo = clienteT.getIndividuo();
				try {
					nombre = (individuo.getApellido().trim() + ", " + individuo.getNombres().trim()).toUpperCase();
				} catch (Exception e) {
					e.printStackTrace();
				}

				Domicilio dom = individuo.getDomicilioDoc();
				if (dom != null && dom.validateDomicilio())
				{
					domicilio = dom.getCalleNombre().trim() + " " + dom.getCalleNumero().trim() + " "
							+ ((dom.getOrientacion() != null) ? dom.getOrientacion() : "-");

					if (dom.getManzana() != null)
						domicilio = domicilio + " Mz. " + dom.getManzana();
					if (dom.getMonoblock() != null)
						domicilio = domicilio + " Mb. " + dom.getMonoblock();
					if (dom.getPiso() != null)
						domicilio = domicilio + " Piso " + dom.getPiso();
					if (dom.getDepto() != null && !dom.getDepto().trim().equals(""))
						domicilio = domicilio + " Dpto. " + dom.getDepto().trim();
					if (dom.getAreaSector() != null && !dom.getAreaSector().trim().equals(""))
						domicilio = domicilio + " Area. " + dom.getAreaSector().trim();

					domicilio = domicilio + " " + dom.getBarrio().getDescripcion().trim();
					localidad = dom.getLocalidad().getPartido().getDescripcion().trim() + " " + dom.getLocalidad().getNombre().trim();
					cp = dom.getCodigoPostal();
					provincia = dom.getLocalidad().getProvincia().getNombre();
					codPost = dom.getCpa2().toString();
				}
				else
				{
					domicilio = clienteT.getDomicilio();
					localidad = clienteT.getLocalidad();
					cp = clienteT.getCodPost();
					provincia = clienteT.getProvincia();
				}

			} catch (Exception e) {
				log.info("Error Domicilio - \n\n");
				e.printStackTrace();
				log.info("\n");
			}

			// el nombre de la liquidacion es la ruta del pdf
			if (codPost == null) {
				codPost = clienteT.getCodPost().trim();
			}
			nombreLiq = rutaRelativa + "/" + codPost + formatoFecha.format(liquidacionCliente.getLiquidacionClientes().getFechaLiquidacion()) + "_"
					+ clienteT.getIdCliente();
			nombreLiqReturn = "/" + nombreLiq.substring(nombreLiq.indexOf("archivos"));

			nombreLiqReturn = "/" + nombreLiq.substring(nombreLiq.indexOf("archivos"));

			String p0 = "?guardarEn=" + nombreLiq;
			String p1 = "ƒliquidacion_numero=" + liquidacionCliente.getIdLiqCliente();
			String p2 = "ƒcuenta_nro=" + liquidacionCliente.getClienteTransaccion().getIdCliente();
			String p3 = "ƒnombre=" + nombre;
			String p4 = "ƒdireccion=" + domicilio;
			String p5 = "ƒdescripcion=" + localidad;
			String p6 = "ƒcp=" + cp;
			String p7 = "ƒciudad=" + provincia;

			String adicional1 = "";
			String adicional2 = "";
			String adicional3 = "";
			int i = 0;
			List adicionalesDelTitular;
			String adicionales = "";
			try {
				adicionalesDelTitular = transaccionesService.getClienteTransaccionService().getCliente(
						new Filtro("idTitular", Filtro.IGUAL, liquidacionCliente.getClienteTransaccion().getIdCliente()));
				Iterator iterAdi = adicionalesDelTitular.iterator();
				while (iterAdi.hasNext()) {
					ClienteTransaccion ad = (ClienteTransaccion) iterAdi.next();
					i++;
					switch (i % 3) {
					case 1:
						try {
							adicional1 = "ƒadi1=" + ad.getNombreCliente();
						} catch (Exception e) {
							adicional1 = "ƒadi1= ";
						}
						break;
					case 2:
						try {
							adicional2 = "ƒadi2=" + ad.getNombreCliente();
						} catch (Exception e) {
							adicional2 = "ƒadi2= ";
						}
						break;
					case 3:
						try {
							adicional3 = "ƒadi3=" + ad.getNombreCliente();
						} catch (Exception e) {
							adicional3 = "ƒadi3= ";
						}
						break;
					}
				}
				adicionales = adicional1 + adicional2 + adicional3;
			} catch (ClienteTransaccionException e1) {
				e1.printStackTrace();
				throw new GestorLiquidacionClienteException("Generacion del PDF: Error en la busqueda del los adicionales de la cuenta.");
			}

			String parametros = "";

			parametros += "ƒdesc1=" + "Int.Compensatorios" + "ƒtna1=" + liquidacionCliente.getIntComp();
			parametros += "ƒdesc2=" + "Int.Punitorio" + "ƒtna2=" + liquidacionCliente.getIntPunitorios();

			String lineaCredito = "";
			lineaCredito += "ƒcredito=" + lineaDeCredito.setScale(BigDecimal.ROUND_HALF_DOWN, 2) + "ƒsaldo="
					+ saldoTotal.setScale(BigDecimal.ROUND_HALF_DOWN, 2) + "ƒdisponible=" + disponible.setScale(BigDecimal.ROUND_HALF_DOWN, 2);

			String repactaciones = "";
			try {
				Object[] liqRepactacion = liquidacionCliente.getLiqClienteRepactacion().toArray();

				Arrays.sort(liqRepactacion, new Comparator() {

					public int compare(Object o1, Object o2) {
						if (((LiqClienteRepactacion) o1).getNroCuota() < ((LiqClienteRepactacion) o2).getNroCuota())
							return -1;
						else if (((LiqClienteRepactacion) o1).getNroCuota() > ((LiqClienteRepactacion) o2).getNroCuota())
							return 1;
						else
							return 0;
					}
				});

				repactaciones = "ƒ1cuota=0";// + ((LiqClienteRepactacion)liqRepactacion[0]).getMontoMinimo();
				repactaciones += "ƒ2cuota=0";// + ((LiqClienteRepactacion)liqRepactacion[0]).getMontoCuota();
				repactaciones += "ƒ3cuota=0";// + ((LiqClienteRepactacion)liqRepactacion[1]).getMontoCuota();
				// repactaciones = "ƒ1cuota=" + pagMi;
				// repactaciones += "ƒ2cuota=" + pagInTres;
				// repactaciones += "ƒ3cuota=" + pagInSeis;
			} catch (Exception e) {
				e.printStackTrace();
				throw new GestorLiquidacionClienteException(
						"Generacion del documento PDF: A ocurrido un error al intentar armar las repactaciones del Cliente.");
			}

			String pagos = "";
			// instancio informacion para luego armar el codigo de barras.
			BigDecimal importePagoFacil = new BigDecimal(0);
			int anio = 0;
			int dias = 0;
			int diasEntreVencimiento = 0;

			try {

				pagos += "ƒf_1_ven=" + sdf.format(fechaPrimerVencimiento);

				lineaCredito += "ƒtotal_resumen=" + liquidacionCliente.getMontoTotal();

				Format dateFormat = new SimpleDateFormat("dd/MM/yyyy");

				Calendar cierreAnterior = Calendar.getInstance();
				cierreAnterior.setTime(liquidacionCliente.getFechaCierreAnterior());
				cierreAnterior.add(Calendar.DATE, 1);
				lineaCredito += "ƒfechaEspecial=" + dateFormat.format(cierreAnterior.getTime());

				lineaCredito += "fechaResumenAnterior=" + dateFormat.format(fechaCierreAnterior);

				importePagoFacil = liquidacionCliente.getMontoTotal().add(new BigDecimal(liquidacionCliente.getMontoAdeudado()))
						.setScale(BigDecimal.ROUND_HALF_DOWN, 2);

				pagos += "ƒf_2_ven=" + sdf.format(fechaSegundoVencimiento);

				pagos += "ƒf_3_ven=" + sdf.format(fechaTercerVencimiento);

				/*
				 * SimpleDateFormat format = new SimpleDateFormat("dd/MM/yy"); fecha1 = format.format(liqPago[0].getFecha()); fecha2 =
				 * format.format(liqPago[1].getFecha()); fecha3 = format.format(liqPago[2].getFecha());
				 */

			} catch (Exception e) {
				e.printStackTrace();
				throw new GestorLiquidacionClienteException(
						"Generacion del documento PDF: A ocurrido un error al intentar armar los pagos del Cliente.");
			}

			// recupero el concepto de MENSAJES (id nro. 12), para obtener la lista de precios que utiliza
			Concepto conceptoParamGen;
			String mensaj = "";
			try {
				conceptoParamGen = transaccionesService.getConceptoService().leerConcepto(new Long(18));
				conceptoParamGen.armarConcepto();
				conceptoParamGen.armarReglaConcepto();
				Set detall = conceptoParamGen.getListaPrecio(idCliente).getVersionVigente().getDetallesListaPrecio();
				int cons = 1;
				ListaPrecioDetalle mensaje = new ListaPrecioDetalle();
				Iterator listaParamGen = detall.iterator();
				while (listaParamGen.hasNext()) {
					ListaPrecioDetalle var = (ListaPrecioDetalle) listaParamGen.next();
					switch (cons) {
					case 1:
						mensaj += "ƒmensaje1= ";
						break;
					case 2:
						mensaj += "ƒmensaje2= ";
						break;
					case 3:
						mensaj += "ƒmensaje3= ";
						break;
					}
					cons++;
				}
			} catch (Exception e1) {
				e1.printStackTrace();
				throw new GestorLiquidacionClienteException(
						"Generacion del documento PDF: A ocurrido un error al intentar armar los mensajes del Cliente. Verifique la existencia del concepto 18 (Mensajes) y que este posea asociado su lista de precios. Se deben encontrar en vigencia.");
			}
			String codigoBarra = "0000";
			String codigoBarraDos = null;
			String codigoBarraTres = null;
			importePagoFacil = importePagoFacil.setScale(2, BigDecimal.ROUND_HALF_DOWN);
			String importePF = importePagoFacil.toString();
			log.info("importePF " + importePF);
			importePF = importePF.substring(0, importePF.indexOf(".")) + importePF.substring(importePF.indexOf(".") + 1, importePF.indexOf(".") + 3);
			log.info("importePF " + importePF);
			if (importePF.contains("-"))
				importePF = "0";

			importePF = ("0000000" + importePF).substring(("0000000" + importePF).length() - 7);

			codigoBarra = "*11"
					+ ("00000000" + liquidacionCliente.getIdLiqCliente()).substring(("00000000" + liquidacionCliente.getIdLiqCliente()).length() - 8)
					+ "0*";
			SimpleDateFormat simpleDateFormat = new SimpleDateFormat("ddMMyy");
			// String fecha = fecha3.substring(0,2)+ fecha3.substring(3,5)+ fecha3.substring(6,8);
			String fecha = simpleDateFormat.format(fechaTercerVencimiento);
			codigoBarraDos = "0181" + ("000000" + idCliente).substring(("000000" + idCliente).length() - 6) + fecha + importePF;
			codigoBarraDos = "*" + getConDigito(codigoBarraDos) + "*";

			codigoBarraTres = fecha + importePF + fecha + importePF;
			codigoBarraTres = "*" + getConDigito(codigoBarraTres) + "*";

			String codBarr = "ƒcodBarr= ";
			String codBarrDos = "ƒcodBarrDos= ";
			String codBarrTres = "ƒcodBarrTres= ";
			liquidacionCliente.setCodBarraUno(codBarr);
			liquidacionCliente.setCodBarraDos(codBarrDos);
			liquidacionCliente.setCodBarraTres(codBarrTres);

			/* @I4899 */
			String page = request.getContextPath() + "/report/LiquidacionSaldo0.jrxml";
			/* @F4899 */

			GeneradorDeInforme gen = new GeneradorDeInforme();
			try {
				// log.info(page+p0+p1+p2+p3+p4+p5+p6+p7+ parametros+lineaCredito+codBarr+codBarrDos+codBarrTres+adicionales+
				// cierresyVencimientos+futurosVencimientos+repactaciones+pagos+ mensaj);
				gen.guardarReporte(page + p0 + p1 + p2 + p3 + p4 + p5 + p6 + p7 + parametros + lineaCredito + codBarr + codBarrDos + codBarrTres
						+ adicionales + repactaciones + pagos + mensaj);
			} catch (JRException e) {
				throw new GestorLiquidacionClienteException("Generacion del documento PDF: A ocurrido un error al intentar grabar el archivo.");
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (Exception e) {
				throw new GestorLiquidacionClienteException("Generacion del documento PDF: A ocurrido un error al intentar grabar el archivo.");
			}
		} catch (ClienteTransaccionException e2) {
			// TODO Auto-generated catch block
			e2.printStackTrace();
		}
		return nombreLiqReturn;
	}


	public String getConDigito(String cadena) {
		int suma = 0;
		for (int i = 0; i < cadena.length(); i++) {
			int pos = Integer.valueOf(cadena.substring(i, i + 1)).intValue();
			suma += pos;
		}
		int dig = suma % 11;
		if (dig >= 10) {
			return cadena + 0;
		} else {
			return cadena + dig;
		}
	}


	/**
	 * Solo se debe utilizar para la liquidacion de clientes Calcula el dia del proximo vencimiento teniendo en cuenta si el mes tiene 30 o 31 dias y
	 * si el dia es feriado.
	 * 
	 * @param fecha
	 * @param dias
	 * @return Un dia de vencimiento habil Esta logica tiene una falla cuando la fechaCierre es un 28 y el anio es viciesto, y en algunos casos no
	 *         utilizados para liquidar
	 */
	private Date addDiasFechaLaborable(Date fechaCierre, int dias) {
		Calendar fecha = Calendar.getInstance();
		Calendar fechaBase = Calendar.getInstance();
		fechaBase.setTime(fechaCierre);
		fecha.setTime(fechaCierre);
		fecha.add(Calendar.DATE, dias);
		int ultimoDiaMes = fechaBase.getActualMaximum(Calendar.DAY_OF_MONTH);
		// Controlo si cambio el mes y lo ajusto segun su ultimo dia
		if (fechaBase.get(Calendar.MONTH) != fecha.get(Calendar.MONTH)
				&& fechaBase.get(Calendar.DAY_OF_MONTH) != ultimoDiaMes) {
			switch (ultimoDiaMes) {
			case 31:
				fecha.add(Calendar.DATE, 1);
				break;
			case 28:
				fecha.add(Calendar.DATE, -2);
				break;
			case 29:
				fecha.add(Calendar.DATE, -1);
				break;
			default:
				break;
			}
		}
		fecha = siguienteLaborable(fecha);
		while (fecha.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY) {
			fecha.add(Calendar.DATE, 1);
			fecha = siguienteLaborable(fecha);
		}

		return fecha.getTime();
	}


	public Calendar siguienteLaborable(Calendar fechaOriginal) {
		if (generalService.getNoLaborableDao().esNoLaborable(
				new Timestamp(fechaOriginal.getTime().getTime()))) {
			fechaOriginal.add(Calendar.DATE, 1);
		}
		return fechaOriginal;
	}


	/**
	 * Crea el directorio de las liquidaciones en la posición especificada por los atributos del contexto.properties, de la siguiente forma:
	 * directorioArchivos/directorioLiquidacionesClientes/carpeta con dd-mm-yyyy
	 * */
	private String crearDirectoriosLiquidacion(Date fechaCierre) throws Exception {
		SimpleDateFormat formatoFecha = new SimpleDateFormat("dd-MM-yyyy");
		PropertieFile prop = new PropertieFile(System.getProperty("catalina.home") + File.separator + "webapps" + File.separator
				+ "contexto.properties");

		String nombreLiq = System.getProperty("catalina.home") + prop.getProperties("directorioArchivos")
				+ File.separator + prop.getProperties("directorioLiquidacionesClientes") + File.separator + formatoFecha.format(fechaCierre);

		directorioRelativoLiquidacion = prop.getProperties("directorioArchivos").replaceAll("/webapps", "")
				+ File.separator + prop.getProperties("directorioLiquidacionesClientes") + File.separator + "Particulares";

		File directorio = new File(nombreLiq);
		try {
			if (!directorio.exists()) {
				directorio.mkdirs();

			}
			// nombreLiq += File.separator+formatoFecha.format(liquidacionClientesEditada.getFechaLiquidacion());
			File directorioInterno = new File(nombreLiq);
			if (!directorioInterno.exists()) {
				directorioInterno.mkdir();
			}
			return nombreLiq;
		} catch (Exception e) {
			log.error(e, e);
			e.printStackTrace();
			throw new Exception("No se ha podido crear el directorio para almacenar las liquidaciones.");
		}

	}


	public Long getCuentaLiquidar() {
		return cuentaLiquidar;
	}


	public void setCuentaLiquidar(Long cuentaLiquidar) {
		this.cuentaLiquidar = cuentaLiquidar;
	}


	public List<ItemLiquidacion> getListaItemsLiquidaciones() {
		return listaItemsLiquidaciones;
	}


	public void setListaItemsLiquidaciones(
			List<ItemLiquidacion> listaItemsLiquidaciones) {
		this.listaItemsLiquidaciones = listaItemsLiquidaciones;
	}


	public Boolean getPermitirLiquidar() {
		return permitirLiquidar;
	}


	public void setPermitirLiquidar(Boolean permitirLiquidar) {
		this.permitirLiquidar = permitirLiquidar;
	}


	public ClienteTransaccion getCliente() {
		return cliente;
	}


	public void setCliente(ClienteTransaccion cliente) {
		this.cliente = cliente;
	}


	public Boolean getVerDetalles() {
		return verDetalles;
	}


	public void setVerDetalles(Boolean verDetalles) {
		this.verDetalles = verDetalles;
	}

}
